Analysis
=======

1 - Targets :: Most important:
----

- Reader might not know yet about Class Reloading --> wonderful world await them
- Reader would like to have quick guide to setup class reloading in there project --> Promise them they will have it --> capture their attention


Ideas:
---

- Very difficult technique, but don't scare them away

Structure:
-----



Content:
=======


Creating the amazing: Java class reloading
============

In Java, class reloading is a very rare topic to come by, you can always find projects that developers have to restart server with every class change and no one complain about it - that is a fact about Java development. We have worked like that since our first day with Java, but is Java class reloading that difficult to achieve, and could that problem be both challenging and exciting to solve? In this article, I will try to address the problem, thus to help you create an amazing day with this Ever-Sacred topic.

Why Java class reloading is so difficult?
------------

Nowadays you can see **[JRebel](http://zeroturnaround.com/software/jrebel/)** advertisement every where, it's a commercial solution for Java class reloading. In their ads, they say it would help boost up 17% our performance. I totally disagree with that, the number would be at least 500% ! It's true. Don't underestimate server restarts as normal waste of time. It's an interruption to your flow of logic, and for myself, it creates a lot of distraction too - I find myself often change to newspaper tab or search for porn with each restarting cycle.

No doubt every developer out there would love to have instant reload, and every Project Manager would love to have that and meet their deadlines. But why they don't buy JRebel licences? Because it's God-Damn expensive. 

Don't misjudge the JRebel guys as greedy bastards, instead, they are just honest people trying to get money for their hard work. Solutions like such is very difficult to implement, and I bet that you can't find another company out there offering a cheaper solution for this. Not even me.

Then what I'm trying doing here?
---------------

I'm here to give you are a free solution to this problem. Believe it or not, class reloading is both difficult and easy. And if after you have read this post and still find it difficult, then I assure you that trying to solve this problem is both challenging and exciting. And a long the way, you will find yourself grown up - as a Java developer, and as a software Architecture.

The first example: Reloading 1 class
=============

Please have a look at this short file:  
*All the files in this article are publicly available at [https://github.com/quanla/classreloading](https://github.com/quanla/classreloading)*

~~~java

package qj.blog.classreloading;

import static java.lang.System.*;

import qj.util.ReflectUtil;
import qj.util.lang.DynamicClassLoader;

/**
 * Created by Quan on 26/10/2014.
 */
public class StaticInt {
	public static void main(String[] args) {
		Class<?> userClass = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.StaticInt$User");

		ReflectUtil.setStaticFieldValue(11, "age", userClass);

		out.println("Seems to be the same class:");
		out.println(userClass.getName());
		out.println(User.class.getName());
		out.println();

		out.println("But why there are 2 different class loaders:");
		out.println(userClass.getClassLoader());
		out.println(User.class.getClassLoader());
		out.println();

		out.println("And different ages:");
		out.println(User.age);
		out.println((int) ReflectUtil.getStaticFieldValue("age", userClass));
	}

	public static class User {
		public static int age = 10;
	}
}


~~~

And here is the output:

~~~
Seems to be the same class:
qj.blog.classreloading.StaticInt$User
qj.blog.classreloading.StaticInt$User

But why there are 2 different class loaders:
qj.util.lang.DynamicClassLoader@3941a79c
sun.misc.Launcher$AppClassLoader@1f32e575

And different age values:
10
11
~~~

So as you can see in this example, classes are not "**Global**". JVM can load and use 2 definitions of the same class at the same time, thus we can switch between them and use flexibly.

Right now you can access my [GitHub](https://github.com/quanla/classreloading), load that source code and play it with yourself.

Here is the explanation of the 2 class definitions living together:

<< image with 2 class loaders on right col >>

As you can see, the 2 classes are not only loaded separately, but also their static members are created separately for each of them.

The default class loader `sun.misc.Launcher$AppClassLoader` is pretty fixed, you can assume that it will stay in the JVM forever - together with all the classes it has loaded (`User` class). But the Dynamic class loader on the other hand can go away (Garbage Collected, or GC-ed ), and we can create as many Dynamic Class loaders as we want, and reload `User` class as many times as we want to. It's easy.

Example 2: Reloading continuously
================

And here is the fun part, let's reload User class as many times as we want

~~~ java
package qj.blog.classreloading;

import qj.util.ReflectUtil;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;

/**
 * Created by Quan on 31/10/2014.
 */
public class ReloadingContinuously {
	public static void main(String[] args) {
		for (;;) {
			Class<?> userClass = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.ReloadingContinuously$User");
			ReflectUtil.invokeStatic("hobby", userClass);
			ThreadUtil.sleep(2000);
		}
	}
	
	@SuppressWarnings("UnusedDeclaration")
	public static class User {
		public static void hobby() {
			playFootball(); // Will comment later
//			playBasketball(); // Will uncomment later
		}
		
		// Will comment later
		public static void playFootball() {
			System.out.println("Play Football");
		}
		
		// Will uncomment later
//		public static void playBasketball() {
//			System.out.println("Play Basketball");
//		}
	}
}
~~~

Here is the output:

~~~
...
Play Football
Play Football
Play Football
Play Basketball
Play Basketball
Play Basketball

~~~

Every time a new instance of `DynamicClassLoader` is created, and we ask it to load the User class, it will go to our "`target/classes`" folder and try to pick up the newest compiled class file and give to us. So we can reload class - on the fly.

<< Image of many Classloaders created and GC-ed >>

Another reason I use this example is also to demonstrate the ability for this approach to reload the class structure - adding new method, removing old method - This has always been the limitation of JVM HotSwap and the main reason why JRebel is so expensive. Well, now we can do it by ourselves, and it's free, right?

As we reached this point, many may feel bored. This is only basics of Java class reloading, and even they have known these many years ago, but still, they have to do server restarts or buy JRebel. Why? because it's very difficult to apply this technique to their real life project. I also cannot guarantee you that this article will help you do class reloading, but I can promise you a good example of a complex web application, thus you can get many lessons about what difficulties you may have while attempting to use this technique.


Example 3: Simple context reloading
==============

Okay, let's have a look at the next example. This time I will set up a simple context, with a service and a model and reload them all together every time we hit enter on the console:

<< >>

As you can see, the main method will have a hold of the context object, and **that is the only link**. If we break that link, the context object and the context class, and the service object ... will all be eligible for GC-ed... With a clean design like this, we know exactly what to be cut and created a new in order to totally dump all the old classes and objects.

A little explanation about why normally classes are so persistent and not get Garbage Collected: it's because normally we load all our classes into the default classloader, and this classloader cache all the classes it has loaded, so as long as the classloader still connected to any alive thread, everything (all loaded classes) will be immune to the Garbage Collector.

Example 4: Reloading context while persisting connection object
============

In the next example I will show you how to save yourself a little more performance by keeping the old good connection object. In actual project, there would be many other things you want to keep through reloading phases, and this contribute to the reason while this topic is so difficult

~~~ java

package qj.blog.classreloading;

import static qj.util.ReflectUtil.*;

import qj.util.ThreadUtil;
import qj.util.lang.ExceptingClassLoader;

/**
 * Created by Quan on 01/11/2014.
 */
public class KeepConnectionPool {
	public static void main(String[] args) {

		ConnectionPool pool = new ConnectionPool();

		for (;;) {
			Object context = createContext(pool);

			invokeService(context);

			ThreadUtil.sleep(2000);
		}
	}

	private static void invokeService(Object context) {
		Object hobbyService = getFieldValue("userService", context);
		invoke("hello", hobbyService);
	}
	
	private static Object createContext(ConnectionPool pool) {
		ExceptingClassLoader classLoader = new ExceptingClassLoader(
				(className) -> className.contains("$Connection"),
				"target/classes");
		Class<?> contextClass = classLoader.load(KeepConnectionPool.class.getName() + "$Context");
		Object context = newInstance(contextClass);
		
		setFieldValue(pool, "pool", context);
		invoke("init", context);

		return context;
	}

	@SuppressWarnings("UnusedDeclaration")
	public static class Context {
		public ConnectionPool pool;
		
		public UserService userService = new UserService();
		
		public void init() {
			userService.pool = pool;
		}
	}
	
	public static class UserService {
		ConnectionPool pool;
		
		@SuppressWarnings("UnusedDeclaration")
		public void hello() {
			System.out.println("UserService CL: " + this.getClass().getClassLoader()); // Will output ExceptingClassLoader
			System.out.println("Hi " + pool.getConnection().getUserName());
		}
	}
	
	public static class ConnectionPool {
		Connection conn = new Connection();
		
		public Connection getConnection() {
			return conn;
		}
	}
	
	public static class Connection {
		public String getUserName() {
			System.out.println("Connection CL: " + this.getClass().getClassLoader()); // Will output DefaultClassLoader
			return "Joe";
		}
	}
}

~~~

Output:

~~~

UserService CL: qj.util.lang.ExceptingClassLoader@4fca772d
Connection CL: sun.misc.Launcher$AppClassLoader@1f32e575
Hi Joe

~~~

Similar setup to Example 3, but this example will focus more on how to cleanly separate the resources need to be reloaded and the ones we need to keep persisted.

<< Image of persisted resources and reloading resources >>

You can see that also the Connection and Connection Pool objects are referred from our reloaded Context and Service, they totally reside in the persisted scope, and loaded by JVM's default class loader.

It's important to keep a clean separation of persisted and reloading resources. If we change the example source code a little bit, replacing line 32 from:

~~~
(className) -> className.contains("$Connection"),
~~~

to

~~~
(className) -> className.contains("$ConnectionPool"),
~~~

Then, as a result, will allow the reloading context to load class `Connection`, then there will be 2 "`Connection`" classes in use at the same time, and you will see this weird error that you may not be able to explain: 

~~~
Caused by: java.lang.LinkageError: loader constraint violation: loader (instance of qj/util/lang/ExceptingClassLoader) previously initiated loading for a different type with name "qj/blog/classreloading/KeepConnectionPool$Connection"
~~~

Here is the visualized context of the error:

<< image with 2 Connection classes in use >>

In your project, you should separate those classes in a separated module, so you don't have to worry that the Dynamic Classloader accidentally load them.


Example 5: The complex Web App with class reloading
=====

This is not the final solution for all the applications out there, the actual solution will vary from project to project, framework to framework. What I'm trying to show here is that it is achievable and with your knowledge of the system and the class reloading mechanism, you will be able to make it happen.




Conclusion:
===

So the key factor to achieve this is to have a super clean design, and with such you can freely manipulate your classes and the whole JVM

What if you don't have a super clean design
--------

Then try to make a super clean design first, because without that, you will never be able to achieve the target. Even if you are quite confident with your design already, but just a little bit confused at some point, then some classes may not be totally cleaned, they will still have link back to the application and thus generate ghost-like behaviors that no one will enjoy. But don't worry, this will only happen during development, and will not affect the customers.

It is a fact, class reloading is very difficult, I'm not trying to scare you. But if you started to do it and at some point you find your classes be loaded on the fly, then you are almost there already. There will be very little thing left to do before you can achieve totally superb clean design for your system.

Good luck my friends and hope you all can do it.





















